name: Label Existing Issues

on:
  workflow_dispatch:

jobs:
  label_existing:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Get Existing Issues
        uses: actions/github-script@v7
        id: get_issues
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            let page = 1;
            let allIssues = [];
            while (true) {
              const { data: issues } = await github.rest.issues.listForRepo({
                owner,
                repo,
                state: 'all', // Or 'open' if you only want to process open issues
                per_page: 100,
                page: page,
              });
              if (issues.length === 0) {
                break;
              }
              allIssues = allIssues.concat(issues);
              page++;
            }
            return JSON.stringify(allIssues); // Return the issues as a JSON string

      - name: Label Existing Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issues = JSON.parse("${{ steps.get_issues.outputs.result }}"); // Access the result
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            for (const issue of issues) {
              const issueTitle = issue.title ? issue.title.toLowerCase() : '';
              const issueBody = issue.body ? issue.body.toLowerCase().replace('frontend version', '') : '';
              const labelsToAdd = [];
              const existingLabels = issue.labels.map(label => label.name);

              // Type Labels (checking body)
              if (issueBody.includes('question') || issueBody.includes('how to')) {
                labelsToAdd.push('question');
              }
              if (issueBody.includes('documentation') || issueBody.includes('docs')) {
                labelsToAdd.push('documentation');
              }

              // Component Labels (checking title)
              if (issueTitle.includes('frontend') || issueTitle.includes('ui')) {
                labelsToAdd.push('Frontend');
              }
              if (issueTitle.includes('backend') || issueTitle.includes('api')) {
                labelsToAdd.push('Backend');
              }
              if (issueTitle.includes('documentation') || issueTitle.includes('docs')) {
                labelsToAdd.push('Documentation');
              }

              // Priority Labels (checking body)
              if (issueBody.includes('critical') || issueBody.includes('urgent') || issueBody.includes('must fix')) {
                labelsToAdd.push('critical');
              }
              if (issueBody.includes('high priority') || issueBody.includes('important')) {
                labelsToAdd.push('high');
              }
              if (issueBody.includes('medium priority') || issueBody.includes('normal')) {
                labelsToAdd.push('medium');
              }
              if (issueBody.includes('low priority') || issueBody.includes('minor')) {
                labelsToAdd.push('low');
              }

              const newLabelsToAdd = labelsToAdd.filter(label => !existingLabels.includes(label));

              if (newLabelsToAdd.length > 0) {
                try {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: issue.number,
                    labels: newLabelsToAdd
                  });
                  console.log(`Added labels ${newLabelsToAdd} to issue #${issue.number}`);
                } catch (error) {
                  console.error(`Failed to add labels to issue #${issue.number}:`, error);
                }
              }
            }
